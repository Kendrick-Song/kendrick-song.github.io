(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{303:function(t,e,a){"use strict";a.r(e);var n=a(14),o=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"part-7-多容器应用-multi-container-apps"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part-7-多容器应用-multi-container-apps"}},[t._v("#")]),t._v(" Part 7：多容器应用（Multi-container apps)")]),t._v(" "),e("p",[t._v("Up to this point, you’ve been working with single container apps. But, now you will add MySQL to the application stack. The following question often arises - “Where will MySQL run? Install it in the same container or run it separately?” In general, each container should do one thing and do it well. The following are a few reasons to run the container separately:")]),t._v(" "),e("ul",[e("li",[t._v("There’s a good chance you’d have to scale APIs and front-ends differently than databases.")]),t._v(" "),e("li",[t._v("Separate containers let you version and update versions in isolation.")]),t._v(" "),e("li",[t._v("While you may use a container for the database locally, you may want to use a managed service for the database in production. You don’t want to ship your database engine with your app then.")]),t._v(" "),e("li",[t._v("Running multiple processes will require a process manager (the container only starts one process), which adds complexity to container startup/shutdown.")])]),t._v(" "),e("p",[t._v("And there are more reasons. So, like the following diagram, it’s best to run your app in multiple containers.")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://docs.docker.com/get-started/images/multi-app-architecture.png",alt:"Todo App connected to MySQL container"}})])])}),[],!1,null,null,null);e.default=o.exports}}]);